{"version":3,"sources":["../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/lib/validators.js","../../src/index.js","App.js","index.js"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","_forIn","target","body","check","keys","key","push","array","reject","i","_cycle","length","_forTo","Symbol","iterator","asyncIterator","_for","test","update","stage","shouldContinue","updateValue","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","_catch","recover","validators","not_empty","email","input","document","parts","az_space","website","person","model","validate","has","getValidationPaths","options","object","paths","Object","_flatten","path","objectBit","Array","console","execValidator","fn","res","Promise","Error","parsePath","oSet","parseOptions","defaultState","errorOptions","assignValues","optPointer","shouldRecurse","statePointer","errorPointer","opts","errorState","validationPaths","stringifyErr","err","watchPaths","useState","setState","errors","setErrors","validatePath","getUpdate","errorHandler","__state","_state","obj","hydrate","useCallback","_errors","type","onChange","oldValue","getValue","name","checkbox","truevalue","falsevalue","newValue","checked","radio","submit","errState","errs","field","error","cb","watch","set","watchers","get","getState","getErrors","App","log","useModels","username","remember","newsletter","user_type","useEffect","onSubmit","onError","previousValue","className","onClick","JSON","stringify","resolve","setTimeout","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.841eacc1.chunk.js","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","// the built in validators\r\nconst validators = {\r\n    not_empty(value){\r\n        return value.length===0? 'can\\'t be empty' : void 0;\r\n    },\r\n    email(value) {\r\n        const input = document.createElement('input');\r\n        input.type = 'email';\r\n        input.value = value;\r\n        var result = input.checkValidity();\r\n        const parts = value.split('@');\r\n        if(parts[1]){\r\n            if(parts[1].indexOf('.') <= 0){\r\n                result = false;\r\n            }\r\n        }else{\r\n            return 'Email Address can\\'t be blank';\r\n        }\r\n        if(!result){\r\n            return 'Invalid Email Address';\r\n        }\r\n    },\r\n    az_space( value  ) {\r\n        if( ! /^[A-Za-z .]+$/.test(value) ){\r\n            return 'Only letters and spaces are allowed.';\r\n        }\r\n    },\r\n    website( value ) {\r\n        if( ! /(^|\\s)((https?:\\/\\/)[\\w-]+(\\.[\\w-]+)+\\.?(:\\d+)?(\\/\\S*)?)/gi.test(value) ) {\r\n            return 'Please enter a valid url.';\r\n        }\r\n    },\r\n    person(value) {\r\n        if( ! /^(-?([A-Z].\\s)?([A-Z][a-z]+)\\s?)+([A-Z]'([A-Z][a-z]+))?$/g.test(value) ) {\r\n            return 'Enter a valid name.'\r\n        }\r\n    }\r\n};\r\n\r\nexport default validators;","import { useState, useCallback, useMemo } from 'react';\nimport validators from './lib/validators';\n\nfunction extendValidators( name, fn ) {\n    validators[name] = fn;\n};\n\nfunction model( value, ...validate) {\n    return { value, validate };\n}\n\nexport { extendValidators, model };\n\nconst has = (o,k) => o[k]!==undefined;\n\nconst flatten = object => {\n  return Object.assign( {}, ...function _flatten( objectBit, path = '' ) {  //spread the result into our return object\n    return [].concat(                                                       //concat everything into one level\n      ...Object.keys( objectBit ).map(                                      //iterate over object\n        key => typeof objectBit[ key ] === 'object' && !Array.isArray(objectBit[key]) ?                       //check if there is a nested object\n          _flatten( objectBit[ key ], !path?key:`${ path }.${ key }` ) :              //call itself if there is\n          ( { [  !path ? key : `${ path }.${ key }` ]: objectBit[ key ] } )                //append object with it’s path as key\n      )\n    )\n  }( object ) );\n};\n\nconst getValidationPaths = (options) => {\n    const paths = flatten(options);\n    for(let k in paths){\n        if(!Array.isArray(paths[k])){\n            paths[k]=[paths[k]];\n        }\n    }\n    console.log('validationPaths',paths);\n    return paths;\n}\n\nfunction execValidator(fn,val) {\n    const executor = typeof fn==='function'?fn:has(validators,fn)?validators[fn]:function noop(){ console.warn('built in validator with name `%s` not found. this is a no-op',fn)};//default-> no op\n    const res = executor(val);\n    if(!(res instanceof Promise)){\n        if(res){\n            return Promise.reject(!(res instanceof Error) ? new Error(res): res);\n        }\n        return Promise.resolve();\n    }\n    return res;\n}\n\nfunction parsePath(path) {\n    return path.split('.');\n}\n\n//recursive assign value to all properties of object\nfunction oSet(o,v) {\n    for(let k in o){\n        if(typeof o[k]==='object'){\n            oSet(o[k],v);\n        }else{\n            o[k]=v;\n        }\n    }\n    return o;\n}\n\nfunction assignValues( optPointer, statePointer, errorPointer ) {\n    for(let k in optPointer) {\n        console.log(k,optPointer[k]);\n        if(typeof optPointer[k]==='object'&&optPointer[k]!==null){\n            let shouldRecurse=true;\n            if(has(optPointer[k],'value')){\n                statePointer[k]=optPointer[k].value;\n                shouldRecurse=false;\n            }\n            if(has(optPointer[k],'validate')){\n                errorPointer[k]=optPointer[k].validate;\n                shouldRecurse=false;\n            }\n            if(shouldRecurse){\n                if(!has(statePointer,k)){\n                    statePointer[k]={};\n                }\n                if(!has(errorPointer,k)){\n                    errorPointer[k]={};\n                }\n                assignValues(optPointer[k],statePointer[k],errorPointer[k]);\n            }\n        }else{\n            statePointer[k]=optPointer[k];\n        }\n    }\n} \n\nfunction parseOptions ( opts ) {\n    console.log('parseOptions()');\n    const defaultState = {};\n    const errorOptions = {};\n    assignValues(opts,defaultState,errorOptions);//this recursive function will populate defaultState and errorOptions for us.\n    const errorState = oSet({...defaultState},false);\n    const validationPaths = getValidationPaths(errorOptions);\n    console.log(defaultState,errorState,validationPaths);\n    return {defaultState,errorState,validationPaths};\n}\n\nfunction stringifyErr( err ) {\n    if(typeof err ==='string'){\n        return err;\n    }else{\n        // Error, or Error like object(eg, custom error classes)\n        if(typeof err==='object' && has(err,'message')) {\n            return err.message;\n        }\n    }\n    return err.toString();//last resort\n}\n\nexport default function useModels(options={}) {\n\n    console.log('useModels()');\n\n    const {defaultState,errorState,validationPaths} = parseOptions(options);\n    const watchPaths={};\n\n    const [state,setState] = useState(defaultState);\n    const [errors,setErrors] = useState(errorState);\n\n    console.log(state,errors);\n\n    const validate = async () => {\n        console.log('validate()');\n        const errs=[];\n        for(let k in validationPaths){\n            for(let i=0;i<validationPaths[k].length;i++){\n                try{\n                    await execValidator(validationPaths[k][i],getValue(k));\n                }\n                catch(e){\n                    errs.push({field:k,error:e});\n                }\n            }\n        }\n\n        console.log('got results',errs);\n        let errState = oSet({...defaultState},false);\n        console.log('errState is',errState);\n        if(errs.length){\n            console.log('got %d errors',errs.length);\n            errs.forEach(err=>{\n                console.log('looking at errors',err.field,err.error);\n                errState=getUpdate(err.field,stringifyErr(err.error),errState);\n            });\n        }\n        console.log(errState);\n        setErrors(errState);    \n        return errs;\n\n    }\n\n    const validatePath = async (path,value) => {\n        console.log('validatePath()');\n        if(has(validationPaths,path)){\n            for(let i=0;i<validationPaths[path].length;i++){\n                try{\n                    await execValidator(validationPaths[path][i],value);\n                }\n                catch(e){\n                    console.log('gotError in validatePath()',e);\n                    return setErrors(getUpdate(path,stringifyErr(e),errors));\n                }\n            }\n            setErrors(getUpdate(path,false,errors));\n        }else{\n            console.log('no validation for field');\n        }\n    };\n\n    let errorHandler =()=>{};\n\n    function getValue(name) {\n        console.log('getValue()');\n        const path = parsePath(name);\n        let value = state;\n        for(let i=0;i<path.length;i++) {\n            value=value[path[i]];\n        }\n        return value;\n    }\n\n    function getUpdate(name,value,__state=state) {\n        console.log('getUpdate()');\n        const _state = {...__state};\n        const path = parsePath(name);\n        if(path.length){\n            var obj = _state;\n            for(let i=0;i<path.length-1;i++) {\n                obj = has(obj,path[i]) ? obj[path[i]] : {};\n            }\n            obj[path[path.length-1]] = value;    \n        }\n        return _state;    \n    }\n\n    function input(name,type=\"text\"){\n        console.log('input()')\n        return {\n            onChange: (e)=>{\n                console.log(e);\n                var value = e;//components like react-select-me pass primitive values\n                if(has(e,'value')){\n                    value = e.value;\n                }\n                console.log(has(e,'target'));\n                if(has(e,'target')){\n                    value = e.target.value;//normal inputs dont\n                }\n                console.log(value);\n                const oldValue = getValue(name);\n                setState(getUpdate(name,value));\n                if(watchPaths[name]){\n                    watchPaths[name](value,oldValue);\n                }\n                validatePath(name,value);\n            },\n            value: getValue(name),\n            name,\n            type\n        };\n    };\n\n    function checkbox(name,truevalue=true,falsevalue=false){\n        console.log('checkbox()');\n        return {\n            onChange: (e)=>{\n                const newValue = e.target.checked?truevalue:falsevalue;\n                const oldValue = getValue(name);\n                setState(getUpdate(name,newValue));\n                if(watchPaths[name]){\n                    watchPaths[name](newValue,oldValue);\n                }\n                validatePath(name,newValue);\n            },\n            checked: getValue(name)===truevalue,\n            type:'checkbox',\n            name,\n            value:truevalue\n        };\n    };\n\n    function radio(name,value=null){\n        console.log('radio()');\n        return {\n            onChange: (e)=>{\n                if(e.target.checked){\n                    const newValue = value;\n                    const oldValue = getValue(name);\n                    setState(getUpdate(name,value))\n                    if(watchPaths[name]){\n                        watchPaths[name](newValue,oldValue);\n                    }\n                    validatePath(name,newValue);\n                }\n            },\n            checked:  getValue(name)===value,\n            type:'radio',\n            name,\n            value\n        };\n    };\n\n    function submit(cb){\n        console.log('submit()')\n        return async e=>{\n            console.log('onSubmit()');\n            e.preventDefault();\n            const errs = await validate();\n            console.log('got result from validate()',errs);\n            if(errs.length){\n                errorHandler(errors,state);\n            }else{\n                cb(state);//send the full state to the submit function\n            }\n            e.stopPropagation();\n        };\n        \n    };\n\n    function error(cb) {\n        console.log('error()');\n        errorHandler=cb;\n        return e=>{\n            console.log('errorHandler()');\n            cb(errors,state);\n        };\n    }\n\n    function getState() {\n        console.log('getState()');\n        return state;\n    }\n\n    function getErrors(){\n        console.log('getErrors()');\n        return errors;\n    }\n\n    function watch( path, fn ) {\n        console.log('watch()')\n        watchPaths[path]=fn;\n        return function unwatch(){\n            delete watchPaths[path];\n        }\n    }\n\n    function set( name, value, validate=true,watchers=true ) {\n        const oldValue = getValue(name);\n        setState(getUpdate(name,value));\n        if(watchers && watchPaths[name]){\n            watchPaths[name](value,oldValue);\n        }\n        if(validate){\n            validatePath(name,value);\n        }\n    }\n\n    function get( name ){\n        return getValue( name );\n    }\n\n    const hydrate = useCallback(( _state, _errors=false )=> {\n        console.log('hydrate()');\n        setState({...state,..._state});\n        if(_errors){\n            setErrors({...errors,..._errors});\n        }\n    },[]);\n    \n    return { input, checkbox, radio, submit, error, errors, state, watch, hydrate, set, get, getState, getErrors, setState, setErrors };\n\n};","import React, { useEffect } from 'react'\n\nimport useModels,{ model, extendValidators } from 'use-models';\n\nextendValidators('checkUsername',function checkIfUserNameExists( value ) {\n    console.log('checkUsername()');\n    return new Promise((resolve,reject)=>{\n        setTimeout(()=>{\n            reject(new Error('That username is taken'));\n        },200);\n    });\n});\n\nexport default function App() {\n\n    console.log('App.render()');\n\n    const { \n        state, errors, input, checkbox, radio, submit, error, watch, hydrate, set\n    } = useModels({\n        name: model('',value => {\n            if( value.length<5 ){\n                return 'Name must be at least 5 characters';\n            }\n        }),\n        username: model('','checkUsername'),\n        email: model('','email'),\n        remember: false,\n        newsletter: 'no',\n        user_type:'user'\n    });\n\n    //we can hydrate the state(and errors), for example from localstorage or a db call\n    useEffect(()=>{\n        hydrate({\n            name:'Garrett',\n            email:'test@test.com',\n            newsletter: 'yes'\n        });\n    },[hydrate]);\n\n    // hydrate({\n    //     name:'Garrett',\n    //     email:'test@test.com',\n    //     newsletter: 'yes'\n    // });\n\n    const onSubmit = submit(state=>{\n        //do something with your form data\n        console.log(state);\n    });\n\n    const onError = error((errors,state)=>{\n        //do something on form submit error\n    });\n\n    watch('username',(value,previousValue)=>{\n        console.log('username changed from %s to %s',previousValue,value);\n    }); // returns a function that unregisters the watcher.\n\n    return (\n        <div className=\"example\">\n            <form onSubmit={onSubmit} onError={onError}>\n                <h3>use-models example</h3>\n                <div className='form-group'>\n                    <label>Select user type:</label>\n                    <div className=\"user-type-select\">\n                        <div className={\"user-type-option\"+(state.user_type==='user'?' selected':'')} onClick={e=>set('user_type','user')}>\n                            Normal User\n                        </div>\n                        <div className={\"user-type-option\"+(state.user_type==='admin'?' selected':'')} onClick={e=>set('user_type','admin')}>\n                            Admin User\n                        </div>\n                    </div>    \n                </div>\n                <div className=\"form-group\">\n                    <label>Name</label>\n                    <input {...input('name')} />\n                    { errors.name && <p className='help-text'>{errors.name}</p> }\n                </div>\n                <div className=\"form-group\">\n                    <label>Desired Username</label>\n                    <input {...input('username')} />\n                    { errors.username && <p className='help-text'>{errors.username}</p> }\n                </div>\n                <div className=\"form-group\">\n                    <label>Email Address:</label>\n                    <input {...input('email','email')} />\n                    { errors.email && <p className='help-text'>{errors.email}</p> }\n                </div>\n                <div className=\"form-group-check\">\n                    <input {...checkbox('remember')} /> <label>Remember me</label>\n                </div>\n                <div className=\"form-group with-nested\">\n                    <label>Sign up for newsletter?</label>\n                    <div className=\"form-group-check\">\n                        <input {...radio('newsletter','yes')} /> <label>Yes, Sign me up!</label>\n                    </div>\n                    <div className=\"form-group-check\">\n                        <input {...radio('newsletter','no')} /> <label>No thanks</label>\n                    </div>\n                </div>\n                <button type=\"submit\">Submit</button>\n                <div className=\"results\">\n                    <div className=\"result-50\">\n                        <strong>State:</strong>\n                        <pre>\n                            {JSON.stringify(state,null,2)}\n                        </pre>\n                    </div>\n                    <div className=\"result-50\">\n                        <strong>Errors:</strong>\n                        <pre>\n                            {JSON.stringify(errors,null,2)}\n                        </pre>\n                    </div> \n                </div>\n                     \n            </form>\n              \n        </div>\n    );\n    \n};","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}